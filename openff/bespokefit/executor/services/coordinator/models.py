"""Models used in coordinator services."""

from openff.bespokefit._pydantic import BaseModel, Field
from openff.bespokefit.executor.services import current_settings
from openff.bespokefit.executor.services.coordinator.stages import StageType
from openff.bespokefit.executor.services.models import Link, PaginatedCollection
from openff.bespokefit.executor.utilities.typing import Status
from openff.bespokefit.schema.fitting import BespokeOptimizationSchema
from openff.bespokefit.schema.results import BespokeOptimizationResults


class CoordinatorGETPageResponse(PaginatedCollection[Link]):
    """The response of by a GET request."""


class CoordinatorGETStageStatus(BaseModel):
    """The status of a coordinator GET request."""

    type: str = Field(..., description="The type of stage.")

    status: Status = Field(..., description="The status of the stage.")
    error: str | None = Field(
        ...,
        description="The error, if any, raised by the stage.",
    )

    results: list[Link] | None = Field(
        ...,
        description="Links to the results generated by this stage.",
    )

    @classmethod
    def from_stage(cls, stage: StageType):
        """Generate this status from a stage."""
        stage_ids = stage.id if hasattr(stage, "id") else stage.ids

        if isinstance(stage_ids, str):
            stage_ids = [stage_ids]
        elif isinstance(stage_ids, dict):
            stage_ids = sorted(
                {
                    stage_id
                    for dict_values in stage_ids.values()
                    for stage_id in dict_values
                },
            )
        elif stage_ids is None:
            pass
        else:
            raise NotImplementedError()

        settings = current_settings()

        base_endpoint = f"{settings.BEFLOW_API_V1_STR}/"

        endpoints = {
            "fragmentation": f"{base_endpoint}{settings.BEFLOW_FRAGMENTER_PREFIX}/",
            "qc-generation": f"{base_endpoint}{settings.BEFLOW_QC_COMPUTE_PREFIX}/",
            "optimization": f"{base_endpoint}{settings.BEFLOW_OPTIMIZER_PREFIX}/",
        }

        return CoordinatorGETStageStatus(
            type=stage.type,
            status=stage.status,
            error=stage.error,
            results=(
                None
                if stage_ids is None
                else [
                    Link(id=stage_id, self=f"{endpoints[stage.type]}{stage_id}")
                    for stage_id in stage_ids
                ]
            ),
        )


class CoordinatorGETResponse(Link):
    """The object model returned by a GET request."""

    smiles: str = Field(
        ...,
        description="The SMILES representation of the molecule that the bespoke "
        "parameters are being generated for.",
    )

    stages: list[CoordinatorGETStageStatus] = Field(
        ...,
        description="The stages of the bespoke optimization.",
    )
    results: BespokeOptimizationResults | None = Field(
        None,
        description="The output of the bespoke optimization.",
    )

    links: dict[str, str] = Field(
        {},
        description="Links to resources associated with the model.",
        alias="_links",
    )

    @classmethod
    def from_task(cls, task: "CoordinatorTask"):
        """Generate this CoordinatorGETResponse from a task."""
        settings = current_settings()

        stages = [
            *task.pending_stages,
            *([] if task.running_stage is None else [task.running_stage]),
            *task.completed_stages,
        ]
        stages_by_type = {stage.type: stage for stage in stages}

        stage_responses = [
            CoordinatorGETStageStatus.from_stage(stage) for stage in stages
        ]

        return CoordinatorGETResponse(
            id=task.id,
            self=(
                f"{settings.BEFLOW_API_V1_STR}/"
                f"{settings.BEFLOW_COORDINATOR_PREFIX}/{task.id}"
            ),
            smiles=task.input_schema.smiles,
            stages=stage_responses,
            results=(
                None
                if "optimization" not in stages_by_type
                else stages_by_type["optimization"].result
            ),
        )


class CoordinatorPOSTBody(BaseModel):
    """The body of a coordinator POST request."""

    input_schema: BespokeOptimizationSchema = Field(..., description="")


class CoordinatorPOSTResponse(Link):
    """The object model returned by a coordinator POST request."""


class CoordinatorTask(BaseModel):
    """
    An internal model that tracks a task (i.e. a bespoke optimization) that is being executed by the executor.
    """

    id: str = Field(..., description="The unique ID associated with this task.")

    input_schema: BespokeOptimizationSchema = Field(..., description="")

    pending_stages: list[StageType] = Field(..., description="")

    running_stage: StageType | None = Field(None, description="")

    completed_stages: list[StageType] = Field([], description="")

    @property
    def status(self) -> Status:
        """Return the status of this task."""
        if (
            self.running_stage is None
            and len(self.completed_stages) == 0
            and len(self.pending_stages) > 0
        ):
            return "waiting"

        if any(stage.status == "errored" for stage in self.completed_stages):
            return "errored"

        if self.running_stage is not None or len(self.pending_stages) > 0:
            return "running"

        if all(stage.status == "success" for stage in self.completed_stages):
            return "success"

        raise NotImplementedError()
