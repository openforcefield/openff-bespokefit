import os.path

import click.exceptions
import pytest
import rich
from openff.qcsubmit.results import TorsionDriveResultCollection
from openff.utilities import get_data_file_path

from openff.bespokefit._tests import does_not_raise
from openff.bespokefit.cli.cache import (
    _connect_to_qcfractal,
    _results_from_file,
    _update_from_qcsubmit_result,
    update_cli,
)


@pytest.mark.parametrize(
    "filename, expected_raises, output",
    [
        pytest.param(
            "torsion_collection.json",
            does_not_raise(),
            "torsion_collection.json loaded as a `TorsionDriveResultCollection`.",
            id="torsiondrive",
        ),
        pytest.param(
            "optimization_collection.json",
            does_not_raise(),
            "optimization_collection.json loaded as a `OptimizationResultCollection`",
            id="optimization",
        ),
        pytest.param(
            "hessian_collection.json",
            pytest.raises(click.exceptions.Exit),
            "[ERROR] The result file",
            id="hessian",
        ),
    ],
)
def test_results_from_file(filename, expected_raises, output):
    """
    Test loading qcsubmit results files.
    """

    console = rich.get_console()

    with console.capture() as capture:
        file_path = get_data_file_path(
            os.path.join("test", "schemas", filename), package_name="openff.bespokefit"
        )

        with expected_raises:
            _ = _results_from_file(console=console, input_file_path=file_path)

    assert output in capture.get().replace("\n", "")


@pytest.mark.parametrize(
    "address, expected_raises, expected_output",
    [
        pytest.param(
            "api.qcarchive.molssi.org:443",
            does_not_raise(),
            "[✓] connected to QCFractal",
            id="QCArchive",
        ),
        pytest.param(
            "api.qcarchive.molssi.com:1",
            pytest.raises(click.exceptions.Exit),
            "[ERROR] Unable to connect to QCFractal due to the following error.",
            id="Error",
        ),
    ],
)
def test_connecting_to_fractal_address(address, expected_raises, expected_output):
    """
    Test connecting to fractal from using an address.
    """
    console = rich.get_console()

    with console.capture() as capture:
        with expected_raises:
            _ = _connect_to_qcfractal(
                console=console, qcf_address=address, qcf_config=None
            )
    assert expected_output in capture.get().replace("\n", "")


def test_connecting_to_fractal_file():
    """
    Try to connect to the QCArchive using an config file.
    """

    console = rich.get_console()

    with console.capture() as capture:
        _ = _connect_to_qcfractal(
            console=console,
            qcf_address="",
            qcf_config=get_data_file_path(
                os.path.join("test", "miscellaneous", "qcfractal.yaml"),
                package_name="openff.bespokefit",
            ),
        )
    assert "[✓] connected to QCFractal" in capture.get()


def test_update_from_qcsubmit(redis_connection):
    """
    Test adding a mocked result to a local redis instance.
    """

    console = rich.get_console()
    qcsubmit_result = TorsionDriveResultCollection.parse_file(
        get_data_file_path(
            os.path.join("test", "schemas", "torsion_collection.json"),
            package_name="openff.bespokefit",
        )
    )

    with console.capture() as capture:
        _update_from_qcsubmit_result(
            console=console,
            qcsubmit_results=qcsubmit_result,
            redis_connection=redis_connection,
        )

    # The terminal output often contains colors that aren't always displayed the same;
    # these patterns miss lots of fancy stuff from rich
    for line in [
        " local results built",
        " results cached",
    ]:
        assert line in capture.get()

    # find the result in redis
    # key is generated by querying the redis_connection object as below, and
    # .hkeys appears to always return a length-1 list of bytes. The result is
    # hardcoded here, generated Feburary 2024
    # key = redis_connection.hkeys(name="qcgenerator:task-ids")[0]
    task_id = redis_connection.hget(
        name="qcgenerator:task-ids",
        key="2b9f751eb62f9e6af02461f8853ffaa1e9beaaccac71ce8eaec8a9ac574d94320438c33a2947a49a7cd6d4af7249d3936fccde8ebc4bcc9c7b3d61d7b0478388",
    )
    if task_id is None:
        # same as above, but key captured in an environment without OpenEye licensed
        task_id = redis_connection.hget(
            name="qcgenerator:task-ids",
            key="1207a547546633062091443e2ac3105735ab98803e9c027786ea0a66049909c7508d64755db29b5193c13887e37203b2901c73a15720e866ee100e4025007e6e",
        )

    assert redis_connection.hget("qcgenerator:types", task_id) == b"torsion1d"


def test_cache_cli_fractal(runner, tmpdir, redis_session, monkeypatch):
    """Test running the cache update cli."""

    # point the CLI to the same redis testing DB
    monkeypatch.setenv("BEFLOW_REDIS_PORT", 5678)

    output = runner.invoke(
        update_cli,
        args=[
            "--qcf-dataset",
            "OpenFF Gen 2 Torsion Set 6 supplemental 2",
            "--qcf-datatype",
            "torsion",
            "--no-launch-redis",
        ],
    )
    assert output.exit_code == 0, print(output.output)
    assert "4. saving local cache" in output.output
